<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MYspegale博客园</title>
  
  
  <link href="https://shenmingyu.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://shenmingyu.gitee.io/"/>
  <updated>2021-10-21T07:31:50.674Z</updated>
  <id>https://shenmingyu.gitee.io/</id>
  
  <author>
    <name>ShenMingyu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>言语理解（一）</title>
    <link href="https://shenmingyu.gitee.io/ShenMingyu/4a8789e1/"/>
    <id>https://shenmingyu.gitee.io/ShenMingyu/4a8789e1/</id>
    <published>2021-10-21T07:08:15.000Z</published>
    <updated>2021-10-21T07:31:50.674Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/css/APlayer.min.css"><script src="/blog/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/blog/js/Meting.min.js"></script><h1 id="成语词语运用"><a class="markdownIt-Anchor" href="#成语词语运用">#</a> 成语词语运用</h1><blockquote><p>消弭：清除、消除某些不好的事情。</p><p>消遁：指消失逃跑。</p></blockquote><blockquote><p>渊渟岳峙：比喻人品德如渊水深沉，如高山耸立。</p><p>钟灵毓秀：指凝聚了天地间的灵气，孕育着优秀的人物。指山川秀美，人才辈出。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/blog/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/blog/js/APlayer.min.js&quot; class=&quot;</summary>
      
    
    
    
    <category term="言语理解" scheme="https://shenmingyu.gitee.io/categories/%E8%A8%80%E8%AF%AD%E7%90%86%E8%A7%A3/"/>
    
    
    <category term="成语" scheme="https://shenmingyu.gitee.io/tags/%E6%88%90%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>管理学——计划与组织</title>
    <link href="https://shenmingyu.gitee.io/ShenMingyu/b872665d/"/>
    <id>https://shenmingyu.gitee.io/ShenMingyu/b872665d/</id>
    <published>2021-10-20T10:18:53.000Z</published>
    <updated>2021-10-20T11:55:24.735Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/css/APlayer.min.css"><script src="/blog/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/blog/js/Meting.min.js"></script><h1 id="管理学"><a class="markdownIt-Anchor" href="#管理学">#</a> 管理学</h1><h2 id="管理职能"><a class="markdownIt-Anchor" href="#管理职能">#</a> 管理职能</h2><ul><li><h5 id="计划职能首要职能"><a class="markdownIt-Anchor" href="#计划职能首要职能">#</a> <mark>计划职能</mark>（首要职能）</h5><p>是指明确管理的总体目标和各分支目标，并围绕这些目标对未来活动的具体行动任务、行动路线、行动方式、行动规则等方案进行规划、选择、筹谋的活动。</p></li><li><h5 id="组织职能"><a class="markdownIt-Anchor" href="#组织职能">#</a> 组织职能</h5><p>是指按计划对企业的活动及其生产要素进行的分派和组合，实在计划制定后进行的活动。</p></li><li><h5 id="控制职能"><a class="markdownIt-Anchor" href="#控制职能">#</a> 控制职能</h5><p>是指包括制定各种控制标准；检查工作是否按计划进行、是否符合既定的标准；若工作发生偏差要及时发出信号，然后分析偏差产生的原因，纠正偏差或制定新的计划，以确保实现组织目标。</p></li><li><h5 id="领导职能"><a class="markdownIt-Anchor" href="#领导职能">#</a> 领导职能</h5><p>是指领导者运用组织赋予的权利，组织、指挥、协调和监督下属人员，完成领导任务的职责和功能。</p></li></ul><h2 id="计划与组织"><a class="markdownIt-Anchor" href="#计划与组织">#</a> 计划与组织</h2><h3 id="一-计划"><a class="markdownIt-Anchor" href="#一-计划">#</a> 一、计划</h3><h4 id="一计划的含义"><a class="markdownIt-Anchor" href="#一计划的含义">#</a> （一）计划的含义</h4><p>计划是指人们在工作或行动之前预先拟定的具体内容与行动安排。</p><h4 id="二计划的内容"><a class="markdownIt-Anchor" href="#二计划的内容">#</a> （二）计划的内容</h4><p>计划包含 “5W1H”。</p><p>What（我们需要做什么？）、Why（我们为什么要去做？）、Who（这件事由谁去做？）、Where（在什么地方做？）、When（什么时候去做？）、How（怎么去做？）</p><h3 id="二-组织"><a class="markdownIt-Anchor" href="#二-组织">#</a> 二、组织</h3><h4 id="一组织的含义"><a class="markdownIt-Anchor" href="#一组织的含义">#</a> （一）组织的含义</h4><p>组织是根据目标和计划的需要明确部门、岗位，并为每个部门和岗位配备相关人员，明确部门和岗位的职责和相互之间的关系。</p><h4 id="二组织的结构设计"><a class="markdownIt-Anchor" href="#二组织的结构设计">#</a> （二）组织的结构设计</h4><ol><li><h5 id="部门化"><a class="markdownIt-Anchor" href="#部门化">#</a> 部门化</h5><p>组织的全体成员被划分到若干个部门，给每一个部门安排一个管理者，统一协调部门内的所有工作。</p></li><li><h5 id="层级化"><a class="markdownIt-Anchor" href="#层级化">#</a> 层级化</h5><p>（1）管理幅度</p><p>​管理者能够<mark>直接指挥或控制</mark>下属的数量。</p><p>（2）管理层次</p><p>​组织中最高管理者到具体（基层）工作人员之间的层级关系。</p><blockquote><ol><li><p>管理层次与组织规模成正比：组织规模越大，包括的成员越多，管理层次也就越多。</p></li><li><p>在组织规模已定的条件下，管理层次与管理幅度成反比：主管直接控制的下属越多，管理层次越少；相反，管理幅度越小，管理层次越多。</p></li></ol></blockquote><p>e.g：</p><p>下图中：</p><p>总经理的管理幅度为 A 产品经理和 B 产品经理，即管理幅度为 2。</p><p>组织的管理层次为总经理到研究人员、生产人员和质量控制人员，即管理层次为 4。</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/b872665d/image-20211020185041680.png" class="" title="image-20211020185041680"></li><li><h5 id="组织设计的重要原则"><a class="markdownIt-Anchor" href="#组织设计的重要原则">#</a> 组织设计的重要原则</h5><ul><li><p>精简</p><p>注意避免机构重叠，头重脚轻，人浮于事。</p></li><li><p>统一</p><p>组织内的权利影响对集中，实施 “一元化管理”。</p></li><li><p>效率</p><p>应使各部门、各环节、组织成员组合成高效的结构形式。</p></li></ul></li></ol><h4 id="三组织结构形式"><a class="markdownIt-Anchor" href="#三组织结构形式">#</a> （三）组织结构形式</h4><ol><li><h5 id="直线制"><a class="markdownIt-Anchor" href="#直线制">#</a> 直线制</h5><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/b872665d/image-20211020185501915.png" class="" title="image-20211020185501915"><p>组织领导关系按垂直系统建立，实行最基础的简单的一元化管理。</p><p>** 适用范围：** 规模较小、人员较少或发展初期的组织。</p></li><li><h5 id="职能制"><a class="markdownIt-Anchor" href="#职能制">#</a> 职能制</h5><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/b872665d/image-20211020190710156.png" class="" title="image-20211020190710156"><p>在组织内设置若干职能部门，职能部门在职责范围内有权向夏季发布命令和指示。</p><p>** 适用范围：** 中小型的、产品品种比较单一的企业或组织。</p></li><li><h5 id="直线职能制"><a class="markdownIt-Anchor" href="#直线职能制">#</a> 直线职能制</h5><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/b872665d/image-20211020191006021.png" class="" title="image-20211020191006021"><p>管理者对下级进行命令，而职能部门对下级只起到业务指导的作用。</p><p>** 适用范围：** 大部分组织。</p></li><li><h5 id="事业部制"><a class="markdownIt-Anchor" href="#事业部制">#</a> 事业部制</h5><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/b872665d/image-20211020191104056.png" class="" title="image-20211020191104056"><p>组织按照地区或经营的各种产品来划分事业部，遵循 “集中决策、分散经营” 的原则，各事业部独立核算、自负盈亏，总部只保留认识决策、预算控制和监督权等权力。</p><p>** 适用范围：** 产品、业务多元化经营的组织或企业，如腾讯、阿里等。</p></li><li><h5 id="模拟分权制"><a class="markdownIt-Anchor" href="#模拟分权制">#</a> 模拟分权制</h5><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/b872665d/image-20211020191141518.png" class="" title="image-20211020191141518"><p>将组织划分为若干个单位，实行模拟独立经营、单独核算的组织形式。模拟分权制是介于直线职能制和事业部制之间的一种组织形式。</p><p>** 适用范围：** 连续生产的大型组织或企业。</p></li><li><h5 id="矩阵制"><a class="markdownIt-Anchor" href="#矩阵制">#</a> 矩阵制</h5><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/b872665d/image-20211020191148623.png" class="" title="image-20211020191148623"><p>矩阵制是由纵向职能部门和横向项目结合而成的组织形式。</p><p>** 适用范围：** 临时性的重大项目以及科研、设计等创新型较强的组织。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/blog/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/blog/js/APlayer.min.js&quot; class=&quot;</summary>
      
    
    
    
    <category term="管理学" scheme="https://shenmingyu.gitee.io/categories/%E7%AE%A1%E7%90%86%E5%AD%A6/"/>
    
    
    <category term="计划与组织" scheme="https://shenmingyu.gitee.io/tags/%E8%AE%A1%E5%88%92%E4%B8%8E%E7%BB%84%E7%BB%87/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript获取元素样式的N种方式</title>
    <link href="https://shenmingyu.gitee.io/ShenMingyu/84297598/"/>
    <id>https://shenmingyu.gitee.io/ShenMingyu/84297598/</id>
    <published>2020-11-28T08:14:49.000Z</published>
    <updated>2021-10-20T11:47:12.219Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/css/APlayer.min.css"><script src="/blog/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/blog/js/Meting.min.js"></script><p>这几天想到了一个很好看的菜单栏样式，在实现的时候发现最原始的 element.style.* 的方法失效了，没办法获取到元素的样式属性值，所以就上网查了很多资料，发现了这种方法的一些局限性以及更多的获取样式的方式，在这里整理一下可以获取属性的各种方法，方便日后的使用。</p><p>首先确认一下  <code>sample</code>  用例代码</p><ol><li>确定实验目录，大概是这样子的，用来检测是否能获取到 <mark>内联</mark>、<mark>内嵌</mark>、<mark>外部</mark> 样式中的样式属性值。</li></ol><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/84297598/image-20201128163015513.png" class="" title="image-20201128163015513"><ol start="2"><li>然后确定整体  <code>HTML</code>  结构</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>getStyle<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- &lt;style&gt;&lt;/style&gt; 块中的样式仅仅用于对 &lt;div id=&quot;testEmbed&quot;&gt;&lt;/div&gt; 的样式进行设置 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;testInline&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;testEmbed&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;testExternal&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>整体  <code>CSS</code>  样式：</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#242424</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="一-eelementstyle"><a class="markdownIt-Anchor" href="#一-eelementstyle">#</a> 一、 <code>Eelement.style</code></h2><p>返回值是一个 <a href="https://developer.mozilla.org/zh-US/docs/DOM/CSSStyleDeclaration"> <code>CSSStyleDeclaration</code> </a> 对象。</p><h3 id="兼容性"><a class="markdownIt-Anchor" href="#兼容性">#</a> 兼容性</h3><p><code>Element.style.*</code>  方法是目前我最常用的一种获取元素样式属性的方法，这个方法的兼容性自然不用多说，直接上图：</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/84297598/image-20201128171027071.png" class="" title="image-20201128171027071"><p>这个方法的权限是可读可写的，而且写入的样式的优先级相当于直接在元素中内联的  <code>style</code>  的优先级，属于最高优先级，而我这次使用的时候忽略掉了该方法的一个使用限制，在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/style">MDN</a> 上是这样说明这个限制的：</p><blockquote><p>通常，要了解元素样式的信息，仅仅使用  <code>style</code>  属性是不够的，这是因为它只包含了在元素内嵌 style 属性（attribute）上声明的的 CSS 属性，而不包括来自其他地方声明的样式，如 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/head"> <code>&lt;head&gt;</code> </a> 部分的内嵌样式表，或外部样式表。要获取一个元素的所有 CSS 属性，你应该使用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/getComputedStyle"> <code>window.getComputedStyle()</code> </a>。</p></blockquote><h3 id="用法"><a class="markdownIt-Anchor" href="#用法">#</a> 用法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> testInline = <span class="built_in">document</span>.getElementById(<span class="string">&quot;testInline&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当需要将样式更换为背景白色，其他样式去除，则使用如下方法：</span></span><br><span class="line">testInline.style.cssText = <span class="string">&quot;background-color: #FFFFFF;&quot;</span>; </span><br></pre></td></tr></table></figure><p>结果是这样的：</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/84297598/image-20201128173204316.png" class="" title="image-20201128173204316"><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当需要仅仅将样式的背景颜色都更换为白色时，</span></span><br><span class="line">testInline.style.backgroundColor = <span class="string">&quot;#FFFFFF&quot;</span>;</span><br></pre></td></tr></table></figure><p>结果是这样的：</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/84297598/image-20201128173232354.png" class="" title="image-20201128173232354"><h2 id="二-windowgetcomputedstyle"><a class="markdownIt-Anchor" href="#二-windowgetcomputedstyle">#</a> 二、 <code>window.getComputedStyle()</code></h2><p>该方法与  <code>element.style.*</code>  不同，他的权限是只读，因此只能读出样式而不能修改样式。</p><p>返回的  <code>style</code>  是一个实时的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CSSStyleDeclaration"> <code>CSSStyleDeclaration</code> </a> 对象，当元素的样式更改时，它会自动更新本身。</p><h3 id="兼容性-2"><a class="markdownIt-Anchor" href="#兼容性-2">#</a> 兼容性</h3><p>这个方法是属于  <code>window</code>  对象的，兼容性如下：</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/84297598/image-20201128170445992.png" class="" title="image-20201128170445992"><p>这个函数可以传入两个参数： <code>window.getComputedStyle(element, [pseudoElt])</code></p><ul><li>第一个参数为 <mark>必传参数</mark> ，是需要获取样式的元素名</li><li>第二个参数现在已经设为 <mark>非必需参数</mark>，是需要获取样式的伪元素或伪类名，如果不需要，可以填入  <code>null</code>  或缺省。</li></ul><h3 id="用法-2"><a class="markdownIt-Anchor" href="#用法-2">#</a> 用法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> testInline = <span class="built_in">document</span>.getElementById(<span class="string">&quot;testInline&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> backgroundColor = <span class="built_in">window</span>.getComputedStyle(testInline, <span class="literal">null</span>).color;</span><br><span class="line">testInline.innerHTML = backgroundColor;</span><br></pre></td></tr></table></figure><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/84297598/image-20201128173731803.png" class="" title="image-20201128173731803"><h2 id="三-elementcurrentstyle"><a class="markdownIt-Anchor" href="#三-elementcurrentstyle">#</a> 三、 <code>Element.currentStyle</code></h2><blockquote><p><code>Element.currentStyle</code>  是一个与 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/getComputedStyle"> <code>window.getComputedStyle</code> </a> 方法功能相同的属性。这个属性实现在旧版本的 IE 浏览器中。</p><p><strong>非标准</strong><br>该特性是非标准的，请尽量不要在生产环境中使用它！</p></blockquote><h3 id="兼容性-3"><a class="markdownIt-Anchor" href="#兼容性-3">#</a> 兼容性</h3><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/84297598/image-20201128221248373.png" class="" title="image-20201128221248373"><h3 id="用法-3"><a class="markdownIt-Anchor" href="#用法-3">#</a> 用法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> testInline = <span class="built_in">document</span>.getElementById(<span class="string">&quot;testInline&quot;</span>);</span><br><span class="line">testInline.currentStyle.backgroundColor = <span class="string">&quot;#FFFFFF&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="四-elementgetattributesetattribute"><a class="markdownIt-Anchor" href="#四-elementgetattributesetattribute">#</a> 四、 <code>Element.getAttribute()/setAttribute()</code></h2><p><code>Element.getAttribute()/setAttribute()</code>  初衷是为了兼容 IE 获取的属性值，在使用的时候样式属性的名称需要使用驼峰命名写法，分别用来获取属性值和设置属性值。</p><p><code>Element.getAttribute(attributeName)</code>  方法需要设置一个参数，即需要查找 / 设置的属性名称。</p><ul><li>若元素存在，则返回元素上一个指定的属性值。</li><li>若不存在，则返回  <code>null</code>  或  <code>&quot;&quot;</code> 。</li></ul><p><code>Element.setAttribute(name, value)</code>  方法需要设置两个参数</p><ul><li>第二个参数为  <code>name</code> ，需要设定的样式属性名</li><li>第三个参数  <code>value</code> ，是需要更改的样式值</li></ul><h3 id="兼容性-4"><a class="markdownIt-Anchor" href="#兼容性-4">#</a> 兼容性</h3><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/84297598/image-20201128222857586.png" class="" title="image-20201128222857586"><h3 id="用法-4"><a class="markdownIt-Anchor" href="#用法-4">#</a> 用法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> testInline = <span class="built_in">document</span>.getElementById(<span class="string">&quot;testInline&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这个设置方法会导致style中只剩下设置的样式，甚至会将块内原本的 HTML 内容删除，因此需要一次性全部进行设置，类似Element.style.cssText 方法，</span></span><br><span class="line">testInline.setAttribute(<span class="string">&quot;style&quot;</span>, <span class="string">&quot;width: 500px;height: 100px;background-color: #FFFFFF;color: #ffffff;font-size: 30px;line-height: 100px;text-align: center;&quot;</span>);</span><br><span class="line">testInline.innerHTML = testInline.getAttribute(<span class="string">&quot;backgroundColor&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="五-elementgetpropertyvalue"><a class="markdownIt-Anchor" href="#五-elementgetpropertyvalue">#</a> 五、 <code>Element.getPropertyValue()</code></h2><p><code>Element.getPropertyValue()</code>  和  <code>Element.getAttribute()</code>  很类似，最主要的区别就在于选取元素的时候的命名格式的不同：前者的格式是使用原生属性名，而后者则使用驼峰的命名格式来进行属性选取。</p><h3 id="兼容性-5"><a class="markdownIt-Anchor" href="#兼容性-5">#</a> 兼容性</h3><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/84297598/image-20201130190750238.png" class="" title="image-20201130190750238"><h3 id="用法-5"><a class="markdownIt-Anchor" href="#用法-5">#</a> 用法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> testInline = <span class="built_in">document</span>.getElementById(<span class="string">&quot;testInline&quot;</span>);</span><br><span class="line">testInline.innerHTML = testInline.getPropertyValue(<span class="string">&quot;background-color&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="实验验证"><a class="markdownIt-Anchor" href="#实验验证">#</a> 实验验证</h2><p>讲了这么多，回归正题，下面我们来根据上面的代码用例做一个实验，看一下常用方法获取的属性情况吧：</p><h3 id="开始实验设置"><a class="markdownIt-Anchor" href="#开始实验设置">#</a> 开始实验设置：</h3><p>内联块直接设定样式为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;testInline&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 500px;height: 100px;background-color: #009999;color: #ffffff;font-size: 30px;line-height: 100px;text-align: center;&quot;</span>&gt;</span>内联样式<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>内嵌样式  <code>&lt;style&gt;&lt;/style&gt;</code>  块中的样式仅仅用于对  <code>&lt;div id=&quot;testEmbed&quot;&gt;&lt;/div&gt;</code>  的样式进行设置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-id">#testEmbed</span> &#123;</span></span><br><span class="line">    width: 500px;</span><br><span class="line">    height: 100px;</span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span>: <span class="selector-id">#990099</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>: <span class="selector-id">#ffffff</span>;</span></span><br><span class="line">    font-size: 30px;</span><br><span class="line">    line-height: 100px;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>外部  <code>style.css</code>  文件的样式仅仅控制  <code>&lt;div id=&quot;testExternal&quot;&gt;&lt;/div&gt;</code>  的样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#testExternal</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#999900</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显示的效果是这样的：</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/84297598/image-20201128165522232.png" class="" title="image-20201128165522232"><p>这时编写  <code>js</code>  代码来进行样式的获取</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/blog/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/blog/js/APlayer.min.js&quot; class=&quot;</summary>
      
    
    
    
    <category term="计算机语言学习" scheme="https://shenmingyu.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="JavaScript" scheme="https://shenmingyu.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://shenmingyu.gitee.io/tags/JavaScript/"/>
    
    <category term="面经" scheme="https://shenmingyu.gitee.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
    <category term="DOM" scheme="https://shenmingyu.gitee.io/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>CSS伪类与伪元素</title>
    <link href="https://shenmingyu.gitee.io/ShenMingyu/a959e4e5/"/>
    <id>https://shenmingyu.gitee.io/ShenMingyu/a959e4e5/</id>
    <published>2020-11-28T08:10:14.000Z</published>
    <updated>2021-10-20T11:48:05.090Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/css/APlayer.min.css"><script src="/blog/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/blog/js/Meting.min.js"></script><p>CSS 中伪类与伪元素的使用是非常常见的，那么究竟什么是伪类，什么是伪元素，他们又需要怎样来使用呢？</p><h2 id=""><a class="markdownIt-Anchor" href="#">#</a> </h2>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/blog/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/blog/js/APlayer.min.js&quot; class=&quot;</summary>
      
    
    
    
    <category term="计算机语言学习" scheme="https://shenmingyu.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="CSS" scheme="https://shenmingyu.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/CSS/"/>
    
    
    <category term="CSS" scheme="https://shenmingyu.gitee.io/tags/CSS/"/>
    
    <category term="面经" scheme="https://shenmingyu.gitee.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>CSS隐藏元素</title>
    <link href="https://shenmingyu.gitee.io/ShenMingyu/2c14192d/"/>
    <id>https://shenmingyu.gitee.io/ShenMingyu/2c14192d/</id>
    <published>2020-11-26T02:09:12.000Z</published>
    <updated>2021-10-20T11:38:23.637Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/css/APlayer.min.css"><script src="/blog/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/blog/js/Meting.min.js"></script><p>面试的时候被问到了  <code>CSS</code>  有哪些隐藏元素的方法，回答的时候只想到了基本元素的隐藏，没有想到文字等元素也是可以隐藏的，也暴露出对一些元素的理解不够深入的问题，写这篇博客来巩固一下。</p><p>首先上一波 sample html、css 代码以及默认展示情况：（两个白色的是参考块，青色的是需要隐藏的）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>隐藏元素<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ref&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;toBeHidden&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;ref&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#242424</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.toBeHidden</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ffffff</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#009999</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.ref</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/2c14192d/image-20201126103440972.png" class="" title="image-20201126103440972"><h2 id="一-width-0-height-0"><a class="markdownIt-Anchor" href="#一-width-0-height-0">#</a> 一、 <code>width: 0; height: 0;</code></h2><p>最普通、最直观也最容易被忽略的一种方法，看过很多类似的博客，都没有提到这种方法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.toBeHidden</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/2c14192d/image-20201126104401427.png" class="" title="image-20201126104401427"><h2 id="二-displaynone"><a class="markdownIt-Anchor" href="#二-displaynone">#</a> 二、 <code>display:none;</code></h2><p><code>display:none;</code>  属性会将设置元素的文档流占位直接去除，因此，在网页中不会显示这个元素，比较推荐这个方式。</p><p>⚠️ <mark>注意：当使用该元素时，如果该元素有  <code>transition</code>  属性，会直接忽略过渡时间和动画，直接消失</mark></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.toBeHidden</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/2c14192d/image-20201126104401427.png" class="" title="image-20201126104401427"><h2 id="三-opacity0"><a class="markdownIt-Anchor" href="#三-opacity0">#</a> 三、 <code>opacity:0;</code></h2><p><code>opacity:0;</code>  属性是将当前元素的设置为全透明，包括其中的背景颜色、字体颜色等等。当我们需要渐隐效果来进行动画过渡的时候可以选择使用这个方法。但是显然这个方法 <mark>不能</mark> 去除元素块的占位</p><p>⚠️ <mark>注意：当使用该元素时，如果该元素有  <code>transition</code>  属性，会根据过渡时间以及过渡动画逐渐消失</mark></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.toBeHidden</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/2c14192d/image-20201126103521477.png" class="" title="image-20201126103521477"><h2 id="四-visibilityhidden"><a class="markdownIt-Anchor" href="#四-visibilityhidden">#</a> 四、 <code>visibility:hidden;</code></h2><p><code>visibility:hidden;</code>  属性可以将当前元素的可见性设置为隐藏，与 <code>display:none;</code>  相比，他没有去除元素的文档流占位，与  <code>opacity:0;</code>  相比，他不是一个连续的隐藏属性，因此无法设置动画。我个人的简单理解就是为了中和上面两者的部分特点，方便一些特殊情况时的使用。</p><p>⚠️ <mark>注意：当使用该元素时，如果该元素有  <code>transition</code>  属性，会直接忽略过渡持续动画，当到达过渡结束时间时，直接消失</mark></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.toBeHidden</span> &#123;</span><br><span class="line">  <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/2c14192d/image-20201126103521477.png" class="" title="image-20201126103521477"><h2 id="五-overflowhidden"><a class="markdownIt-Anchor" href="#五-overflowhidden">#</a> 五、 <code>overflow:hidden;</code></h2><p><code>overflow:hidden;</code>  属性可以将溢出元素大小的内容直接进行隐藏，因此该属性不是对属性自身进行隐藏，而是对其子元素进行隐藏，设置这个属性时，可以添加一个父级元素，并将其高度设置为 0。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;toBeHidden&quot;</span>&gt;</span>把我隐藏<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.father</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: auto;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/2c14192d/image-20201126104401427.png" class="" title="image-20201126104401427"><!-- 当我们仅仅需要对元素内文字进行隐藏的时候也可以使用 overflow:hidden; 属性的方法。 --><h2 id="六-z-index"><a class="markdownIt-Anchor" href="#六-z-index">#</a> 六、 <code>z-index:;</code></h2><p>这个属性的设置需要配合  <code>position</code>  属性同时设置，可以将当前元素的层级设置为负数，如果确认不显示，则越小越好，这样就不会影响到可能同样设置为负数的其他元素，当  <code>position</code>  为  <code>absolute</code>  时，会失去占位，当  <code>position</code>  为  <code>relative</code>  时，会保持占位。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.toBeHidden</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">999</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/2c14192d/image-20201126104401427.png" class="" title="image-20201126104401427"><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.toBeHidden</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">999</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/2c14192d/image-20201126103521477.png" class="" title="image-20201126103521477"><h2 id="七-positionabsolute"><a class="markdownIt-Anchor" href="#七-positionabsolute">#</a> 七、 <code>position:absolute;</code></h2><p>有时候我们希望做到元素从其他看不到的地方通过动画进行显示，这是我们还可以使用  <code>position:absolute;</code>  属性进行设置</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.toBeHidden</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="comment">/* 这里为了方便展示，所以只左移200px方便观察 */</span></span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">200px</span>;</span><br><span class="line">  <span class="comment">/* 搭配以下属性，即可随意移动该元素的位置，并且不会导致页面出现横向滚动条</span></span><br><span class="line"><span class="comment">  top:; left:; bottom:; right:;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/2c14192d/image-20201126104933411.png" class="" title="image-20201126104933411"><h2 id="八-clip-path-polygon0"><a class="markdownIt-Anchor" href="#八-clip-path-polygon0">#</a> 八、 <code>clip-path: polygon(0)</code></h2><p><code>clip-path</code>  属性经常用在切割出多边形的情况下，可以设定切割位置来实现全部隐藏的效果</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.toBeHidden</span> &#123;</span><br><span class="line">  <span class="attribute">clip-path</span>: <span class="built_in">polygon</span>(<span class="number">0px</span> <span class="number">0px</span>, <span class="number">0px</span> <span class="number">0px</span>, <span class="number">0px</span> <span class="number">0px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/2c14192d/image-20201126103521477.png" class="" title="image-20201126103521477"><h2 id="九-transform-scale0"><a class="markdownIt-Anchor" href="#九-transform-scale0">#</a> 九、 <code>transform: scale(0);</code></h2><p><code>transform</code>  属性常用在过渡动画效果设置当中，我们同样可以设置当前块的规模比例为 0，即  <code>transform: scale(0);</code></p><p>需要注意的是： <code>transform: scale(0);</code>  并不会使元素脱离文档流，因此其占位仍然存在，可以理解为改变的仅仅是元素块的显示大小而没有改变占位大小。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.toBeHidden</span> &#123;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/2c14192d/image-20201126103521477.png" class="" title="image-20201126103521477"><h2 id="十-background-color-transparent"><a class="markdownIt-Anchor" href="#十-background-color-transparent">#</a> 十、 <code>background-color: transparent</code></h2><p>有时我们仅仅需要调整背景颜色来进行背景的隐藏，那么只需要使用  <code>background-color: transparent</code>  属性就可以完成。这样的弊端显然是不能控制元素块内的文字的显示情况的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.toBeHidden</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/2c14192d/image-20201126110747091.png" class="" title="image-20201126110747091"><h2 id="十一-font-size0"><a class="markdownIt-Anchor" href="#十一-font-size0">#</a> 十一、 <code>font-size:0;</code></h2><p>当我们只需要对元素内文字进行隐藏时，可以将文字的大小直接设置为 0。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.toBeHidden</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/2c14192d/image-20201126105912948.png" class="" title="image-20201126105912948"><p>显然这样是仅仅隐藏了文字的方法。</p><h2 id="十二-color-transparent"><a class="markdownIt-Anchor" href="#十二-color-transparent">#</a> 十二、 <code>color: transparent;</code></h2><p>仅仅对文字进行隐藏的时候还可以把文字的颜色设置为透明色，这样单从视觉效果上看，文字是隐藏起来的。</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/2c14192d/image-20201126105912948.png" class="" title="image-20201126105912948">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/blog/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/blog/js/APlayer.min.js&quot; class=&quot;</summary>
      
    
    
    
    <category term="计算机语言学习" scheme="https://shenmingyu.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="CSS" scheme="https://shenmingyu.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/CSS/"/>
    
    
    <category term="CSS" scheme="https://shenmingyu.gitee.io/tags/CSS/"/>
    
    <category term="面经" scheme="https://shenmingyu.gitee.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>腾讯校招面经（一）</title>
    <link href="https://shenmingyu.gitee.io/ShenMingyu/85f657b1/"/>
    <id>https://shenmingyu.gitee.io/ShenMingyu/85f657b1/</id>
    <published>2020-11-14T06:25:35.000Z</published>
    <updated>2021-10-20T11:38:23.641Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/css/APlayer.min.css"><script src="/blog/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/blog/js/Meting.min.js"></script><p>这段时间面试了腾讯的前端实习岗位，记录一下被问到的问题。</p><p>（短时间内没时间写出具体解答，以后抽时间完成）</p><p>✅ CSS：隐藏元素的方法</p><p>计算机网络：TCP/IP 的三次握手的目的是什么，四次挥手的过程是什么</p><p>网络传输速度 TCP 的影响因素有哪些</p><p>Nginx 的主要功能</p><p>两栏布局</p><p>伪类、伪元素有哪些、怎么用</p><p>Js 文件大，怎么做才能提高网页速度？</p><p><a href="https://zhidao.baidu.com/question/1387559842172733580.html">https://zhidao.baidu.com/question/1387559842172733580.html</a></p><p>Js 处理 post 和 get 的方法</p><p>Html5 以及之前的 html4.x 的区别</p><p>前端独立请求后端数据文件，nodejs</p><p>懒加载是什么？怎么实现？</p><p>flux 是什么</p><p>MVC 是什么，有什么用</p><p>学习 js 过程中遇到了哪些错误？怎么解决的？</p><p><a href="https://blog.csdn.net/weixin_46077178/article/details/105461240">https://blog.csdn.net/weixin_46077178/article/details/105461240</a></p><p>修改密码修改昵称</p><p>收藏的数据库请求</p><p>三次握手四次挥手</p><p>文档流是什么？哪些方法可以脱离文档流</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/blog/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/blog/js/APlayer.min.js&quot; class=&quot;</summary>
      
    
    
    
    <category term="面试经验积累" scheme="https://shenmingyu.gitee.io/categories/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/"/>
    
    
    <category term="面经" scheme="https://shenmingyu.gitee.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript理解闭包2</title>
    <link href="https://shenmingyu.gitee.io/ShenMingyu/334185e7/"/>
    <id>https://shenmingyu.gitee.io/ShenMingyu/334185e7/</id>
    <published>2020-11-11T12:45:00.000Z</published>
    <updated>2021-10-20T11:38:23.639Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/css/APlayer.min.css"><script src="/blog/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/blog/js/Meting.min.js"></script><p>经过一段时间的深入学习之后，发现之前的对闭包的理解略有偏差，在一些理解的表述上也不是很透彻，因此更新一篇来更好地理解。</p><h2 id="闭包重理解"><a class="markdownIt-Anchor" href="#闭包重理解">#</a> 闭包重理解</h2><p>闭包直观的理解就是将一些属性放入一个闭合的包内，使得这个包内的属性不能被包的外部访问到，这就是闭包要理解好闭包，就必须要理解 <mark>作用域链</mark>、<mark>执行上下文</mark> 以及 <mark>任务队列</mark>的概念，对于闭包，其中最主要的就是 <mark>作用域链</mark> 的概念，因为闭包实际就相当于将变量对象保存在一个包内，作为私有变量对象，不被外部轻易访问。</p><h3 id="执行上下文"><a class="markdownIt-Anchor" href="#执行上下文">#</a> 执行上下文</h3><p>在  <code>JavaScript</code>  中的执行上下文一共分为三种：</p><ul><li>全局环境</li><li>函数环境</li><li>Eval 环境</li></ul><p>由于  <code>JavaScript</code>  是单线程执行语言，即一次只执行一个任务，对于执行上下文，执行时使用到了栈  <code>Stack</code>  的执行顺序，比方说有如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  b();</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    c();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;我是c函数&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数执行的过程模拟如下图：</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/334185e7/image-20201111210825556.png" class="" title="image-20201111210825556"><p>简单理解 <mark>执行上下文</mark> ，就是当前层级下的语句上下文。而当出现当前执行上下文中没有某一变量对象的定义时，根据 <mark>作用域链</mark> 的概念，当前的执行上下文实际包含了上层所有的执行上下文</p><h3 id="作用域链"><a class="markdownIt-Anchor" href="#作用域链">#</a> 作用域链</h3><p>如上所述，比如有代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;这里是全局执行上下文&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">books</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;这里是 books 函数对象执行上下文&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> book = <span class="string">&quot;书包里的书&quot;</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;这里是匿名函数对象执行上下文&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(book);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bag = books();</span><br><span class="line">bag();</span><br></pre></td></tr></table></figure><p>在上面这个例子中，匿名函数里  <code>console.log(book);</code>  中的  <code>book</code>  在匿名函数的执行上下文，即  <code>console.log(book);</code>  语句的上下并没有出现  <code>book</code>  的声明定义，因此原本匿名函数的执行上下文就会扩大到上一层级，向  <code>books</code>  函数对象的执行上下文中寻找，此时发现了  <code>book</code>  变量，这就是因为匿名函数的执行上下文包含了  <code>books</code>  函数对象的执行上下文：</p><ul><li>匿名函数执行上下文 = {作用域链：{匿名函数变量对象 +  <code>books</code>  变量对象 + 全局变量对象}，{本层变量对象：}}</li><li><code>books</code>  函数执行上下文 = {作用域链：{ <code>books</code>  变量对象 + 全局变量对象}，{本层变量对象： <code>book</code> }}</li><li>全局执行上下文 = {作用域链：{全局变量对象}，{本层变量对象： <code>bag</code> ,  <code>books</code> }}</li></ul><p>这一点在其他大部分计算机语言当中都是有所体现的。</p><h3 id="任务队列"><a class="markdownIt-Anchor" href="#任务队列">#</a> 任务队列</h3><p>当我们使用  <code>setTimeout()</code>  和  <code>setInterval()</code>  时，浏览器会帮我们把其内部的语句执行，但是执行的结果并不直接输出，而是放入任务队列中，这里就涉及到 <mark>任务队列</mark> 的概念：</p><p>在  <code>JavaScript</code>  中，由于是单线程执行代码，这样的特性在执行时间需求很长的部分代码时必定会导致整体的运行速度大幅降低，这样显然是不行的，因此需要进行异步的代码处理，代码的执行顺序一共有三个队列：</p><ul><li>主队列：即全局执行上下文直接执行的执行栈</li><li>微队列：用来保存待执行的微任务（回调），比如：promise 的回调、MutationObserver 的回调</li><li>宏队列：用来保存待执行的宏任务（回调），比如：定时器回调、DOM 事件回调、ajax 回调</li></ul><p>代码执行的优先级如上面的排列，<mark>主队列 &gt; 微队列 &gt; 宏队列</mark>，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;主队列任务1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;宏队列任务1&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;宏队列任务2&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;微队列任务1&#x27;</span>, value);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">2</span>).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;微队列任务2&#x27;</span>, value);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;主队列任务2&quot;</span>);</span><br></pre></td></tr></table></figure><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/334185e7/image-20201111213855601.png" class="" title="image-20201111213855601"><p>显然在使用  <code>Promise</code>  的时候，会将  <code>Promise</code>  的任务立即放入微任务队列中，而且跟女执行结果，微任务队列的执行优先级是高于宏任务队列，即  <code>setTimeout()</code>  的内部任务的。</p><p>讲了这么多，但是却感觉始终没有说到点上，这是因为上面的这些实际上是词法作用域的重要规则，在作用域链的例子当中，体现的是词法作用域的查找规则，而这个规则是闭包的非常重要的一部分而已。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/blog/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/blog/js/APlayer.min.js&quot; class=&quot;</summary>
      
    
    
    
    <category term="计算机语言学习" scheme="https://shenmingyu.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="JavaScript" scheme="https://shenmingyu.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/JavaScript/"/>
    
    
    <category term="javascript" scheme="https://shenmingyu.gitee.io/tags/javascript/"/>
    
    <category term="闭包" scheme="https://shenmingyu.gitee.io/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript理解闭包1</title>
    <link href="https://shenmingyu.gitee.io/ShenMingyu/4df27279/"/>
    <id>https://shenmingyu.gitee.io/ShenMingyu/4df27279/</id>
    <published>2020-10-31T09:35:56.000Z</published>
    <updated>2020-11-11T12:48:14.599Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/css/APlayer.min.css"><script src="/blog/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/blog/js/Meting.min.js"></script><p>学习 JavaScript 的过程中，常会遇到有关闭包的问题，面试题中也常常出现与闭包相关的问题，经过学习查阅资料发现闭包本身是 JavaScript 语言中的一个难点，而且闭包始终存在于我们的程序代码当中，因此写一篇博客来记录学习的过程。</p><h2 id="闭包是什么"><a class="markdownIt-Anchor" href="#闭包是什么">#</a> 闭包是什么</h2><blockquote><p>闭包是指有权访问另外一个函数作用域中的变量的函数。——《JavaScript 高级程序设计》</p></blockquote><p>之前在学习过程中理解了作用域的概念，在函数体外部是无法访问到函数体内部的变量的，即局部变量无法从外部读取。使用 let 类型变量会自动生成一个块级作用域（&gt;ES6），而函数本身即为函数作用域。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> outerValue = <span class="string">&quot;外部变量&quot;</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">out</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> innerValue = <span class="string">&quot;内部变量&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;内部-&quot;</span> + innerValue);<span class="comment">// 可以读取并输出</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;内部-&quot;</span> + outerValue);<span class="comment">// 可以读取并输出</span></span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;外部-&quot;</span> + outerValue);<span class="comment">// 可以读取并输出</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;外部-&quot;</span> + innerValue);<span class="comment">// 无法读取，会报错{% asset_img image-20201031175056987.png image-20201031175056987 %}</span></span><br></pre></td></tr></table></figure><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/4df27279/image-20201031175056987.png" class="" title="image-20201031175056987"><h2 id="闭包的特点及其用途"><a class="markdownIt-Anchor" href="#闭包的特点及其用途">#</a> 闭包的特点及其用途</h2><h3 id="1-从外部读取内部局部变量"><a class="markdownIt-Anchor" href="#1-从外部读取内部局部变量">#</a> 1. 从外部读取内部局部变量</h3><p>在很多情况下，我们是需要在外部访问到内部的变量的，而且这里有一个情况：</p><ul><li>我们需要获取的并不是这个局部变量（比如上例中的 innerValue）的值，而是直接根据这个局部变量的地址进行更改（比如在调用函数的时候，让这个变量始终存在且增长）</li></ul><p>这时显然是无法使用  <code>return</code>  关键词来实现，也无法直接在全局定义变量来实现，因此诞生一种想法：使用一个内部函数来读取函数的内部变量，并通过外部函数返回内部函数，从而实现直接调用内部函数来使用外部函数的内部变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">out</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> innerValue = <span class="string">&quot;内部变量&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;内部函数访问外部函数innerValue：&quot;</span> + innerValue);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将 inn() 函数作为返回值</span></span><br><span class="line">  <span class="keyword">return</span> inn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回的 inn() 函数</span></span><br><span class="line"><span class="keyword">let</span> inner = out();</span><br><span class="line">inner(); <span class="comment">// 相当于执行 inn() 函数</span></span><br></pre></td></tr></table></figure><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/4df27279/image-20201031222221638.png" class="" title="image-20201031222221638"><h3 id="2-保证变量始终保存在内存中"><a class="markdownIt-Anchor" href="#2-保证变量始终保存在内存中">#</a> 2. 保证变量始终保存在内存中</h3><p>使用闭包可以保证变量始终存在于内存当中而不会因为函数的结束而导致变量被释放</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">out</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> innerValue = <span class="number">5212</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">innerValue += <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(innerValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> inn;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> inner = out();</span><br><span class="line">inner();</span><br><span class="line">inner();</span><br><span class="line">inner();</span><br></pre></td></tr></table></figure><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/4df27279/image-20201031232414549.png" class="" title="image-20201031232414549"><h2 id="闭包的问题"><a class="markdownIt-Anchor" href="#闭包的问题">#</a> 闭包的问题</h2><h3 id="1-内存消耗大内存泄漏"><a class="markdownIt-Anchor" href="#1-内存消耗大内存泄漏">#</a> 1. 内存消耗大，内存泄漏</h3><p>由上述的 [保证变量始终保存在内存中](# 2. 保证变量始终保存在内存中)，这样做的问题也很明显，即变量会一直保存在内存当中，导致内存的消耗很大，这是因为即便表面上看外部函数已经结束引用了，但实际上内部的  <code>inn()</code>  函数始终保持着对  <code>out()</code>  函数的引用，所以其整体占用的内存始终无法被释放，因此在使用闭包的时候，必须要注意不能滥用，这可能会导致内存泄漏的问题。</p><h4 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法">#</a> 解决方法</h4><p>在推出函数前，先将不再继续使用的局部变量进行删除操作，释放内存空间。</p><h3 id="2-从外部改变内部的值"><a class="markdownIt-Anchor" href="#2-从外部改变内部的值">#</a> 2. 从外部改变内部的值</h3><p>由于闭包的特点，我们可以从函数体的外部直接对函数体内部的局部变量进行修改，因此当我们把外层函数作为一个对象（  <code>object</code>  ）使用的时候，会把这整个闭包作为该对象的 <mark>公有方法</mark>（  <code>public</code>  ），而把内部的局部变量作为其 <mark>私有属性</mark>（  <code>private</code>  ），因此需要特别注意不要随便修改外层函数（外层对象）内部变量的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这里定义 outValue 时注意使用 var 而不是 let，这是有关作用域的细节问题，会在另一篇博客中详细讨论</span></span><br><span class="line"><span class="keyword">var</span> outValue = <span class="string">&quot;函数外部变量&quot;</span>;</span><br><span class="line"><span class="comment">// 定义一个对象</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">outValue: <span class="string">&quot;对象内部变量&quot;</span>,</span><br><span class="line">getValueFunction: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里设置一个打印 this 是为了将这里的 this 属性与 return 的 function 内 return 的 this 作区分</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.outValue;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(object.getValueFunction()());<span class="comment">// 但这里会输出外部变量 outValue 的值&quot;函数外部变量&quot;</span></span><br></pre></td></tr></table></figure><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/4df27279/image-20201101022637048.png" class="" title="image-20201101022637048"><p>从这里可以看到在对象  <code>object</code>  内的属性  <code>getValueFunction</code>  中的  <code>this</code>  值指向的是  <code>object</code>  对象，而在 return 的匿名函数中的  <code>this</code>  并没有如我们原本期望的那样指向  <code>object</code>  对象，而是指向了  <code>Window</code>  对象，这即形成了一个闭包：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getValueFunction: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.outValue;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的例子可以很好的说明闭包的第二个问题所在，而且也可以体现出闭包内变量始终不会被释放的情况。当作了一个公有的方法，名为  <code>getValueFunction()</code> ，并将内部私有属性  <code>outNumber</code>  从函数外部直接进行调用修改，显然这样做是不安全的因此在使用的时候一定要特别注意闭包对外部函数的局部变量（外部对象的私有属性）的修改情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这里定义 outValue 时注意使用 var 而不是 let，这是有关作用域的细节问题，会在另一篇博客中详细讨论</span></span><br><span class="line"><span class="keyword">var</span> outValue = <span class="string">&quot;函数外部变量&quot;</span>;</span><br><span class="line"><span class="comment">// 定义一个对象</span></span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">outValue: <span class="string">&quot;对象内部变量&quot;</span>,</span><br><span class="line">outNumber: <span class="number">1</span>,</span><br><span class="line">getValueFunction: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里设置一个打印 this 是为了将这里的 this 属性与 return 的 function 内 return 的 this 作区分</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">var</span> that = <span class="built_in">this</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    that.outNumber++;</span><br><span class="line">      <span class="keyword">return</span> that.outNumber;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(object.getValueFunction()());<span class="comment">// 但这里会输出外部变量 outValue 的值&quot;函数外部变量&quot;</span></span><br></pre></td></tr></table></figure><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/4df27279/image-20201101194659472.png" class="" title="image-20201101194659472">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/blog/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/blog/js/APlayer.min.js&quot; class=&quot;</summary>
      
    
    
    
    <category term="计算机语言学习" scheme="https://shenmingyu.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="JavaScript" scheme="https://shenmingyu.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/JavaScript/"/>
    
    
    <category term="javascript" scheme="https://shenmingyu.gitee.io/tags/javascript/"/>
    
    <category term="闭包" scheme="https://shenmingyu.gitee.io/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中变量类型的转换</title>
    <link href="https://shenmingyu.gitee.io/ShenMingyu/a45d0102/"/>
    <id>https://shenmingyu.gitee.io/ShenMingyu/a45d0102/</id>
    <published>2020-10-30T15:09:27.000Z</published>
    <updated>2020-10-31T09:36:30.347Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/css/APlayer.min.css"><script src="/blog/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/blog/js/Meting.min.js"></script><p>在编写 javascript 时，有时会遇到需要将变量类型与  <code>String</code>  类型相互转换的情况，下面记录有关  <code>String</code>  类型转换的各种方法：这里仅举出简单的函数作用例子，这些函数的使用是有坑的。</p><h2 id="string-number"><a class="markdownIt-Anchor" href="#string-number">#</a> String &gt;&gt; Number</h2><h3 id="parseint-函数"><a class="markdownIt-Anchor" href="#parseint-函数">#</a>  <code>parseInt()</code>  函数</h3><p>parseInt () 函数可以传入两个参数，第一个参数是要转换的变量，第二个参数确定转换进制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;52.1.2&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">parseInt</span>(str));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseInt</span>(str));</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/a45d0102/image-20201031000059713.png" class="" title="image-20201031000059713"><h3 id="parsefloat-函数"><a class="markdownIt-Anchor" href="#parsefloat-函数">#</a>  <code>parseFloat()</code>  函数</h3><p>与 parseInt () 函数类似，将变量转换为浮点数类型数值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;52.1.2&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">parseFloat</span>(str));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">parseFloat</span>(str));</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/a45d0102/image-20201031000230821.png" class="" title="image-20201031000230821"><h3 id="number-函数"><a class="markdownIt-Anchor" href="#number-函数">#</a>  <code>Number()</code>  函数</h3><blockquote><p>Number () 函数的运行效率是 JsPerf 中最慢的之一，因此不常用</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;52.1.2&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Number</span>(str));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>(str));</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/a45d0102/image-20201031000303117.png" class="" title="image-20201031000303117"><h3 id="隐式转换一元运算符"><a class="markdownIt-Anchor" href="#隐式转换一元运算符">#</a> 隐式转换，一元运算符</h3><blockquote><p>网上有人说这实际上是钻了弱类型语言的空子，从而达到类型转换的目的</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">&quot;5212&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> num = str / <span class="number">2</span>;<span class="comment">// 注意这里不仅仅是 “/” 可以，“*”、“-” 都可以达到类型转换的目的</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num);<span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(num);<span class="comment">// 2606</span></span><br></pre></td></tr></table></figure><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/a45d0102/image-20201031000632725.png" class="" title="image-20201031000632725"><h2 id="number-string"><a class="markdownIt-Anchor" href="#number-string">#</a> Number &gt;&gt; String</h2><h3 id="tostring-函数"><a class="markdownIt-Anchor" href="#tostring-函数">#</a>  <code>toString()</code>  函数</h3><p><code>Number</code>  作为一个基本类，可以使用内部类  <code>toString()</code>  方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">5212</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num.toString());</span><br><span class="line"><span class="built_in">console</span>.log(num.toString());</span><br></pre></td></tr></table></figure><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/a45d0102/image-20201031001057358.png" class="" title="image-20201031001057358"><h3 id="string-函数"><a class="markdownIt-Anchor" href="#string-函数">#</a>  <code>String()</code>  函数</h3><p><code>String()</code>  函数把对象的值转换为字符串，必须传入一个  <code>object</code>  参数类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">5212</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">String</span>(num));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(num));</span><br><span class="line"><span class="keyword">let</span> object = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">String</span>(object));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(object));</span><br></pre></td></tr></table></figure><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/a45d0102/image-20201031001828474.png" class="" title="image-20201031001828474"><h3 id="tofixed-函数"><a class="markdownIt-Anchor" href="#tofixed-函数">#</a>  <code>toFixed()</code>  函数</h3><p><code>Number</code>  作为一个基本类，可以使用内部类  <code>toFixed()</code>  方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">52.12</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num.toFixed());<span class="comment">// toFixed() 函数可以传入参数来控制小数点位数</span></span><br><span class="line"><span class="comment">// console.log(num.toFixed(-1));// 传入参数非负数，否则会报错</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toFixed(<span class="number">0</span>));</span><br><span class="line"><span class="built_in">console</span>.log(num.toFixed(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(num.toFixed(<span class="number">2</span>));</span><br></pre></td></tr></table></figure><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/a45d0102/image-20201031002242478.png" class="" title="image-20201031002242478"><h3 id="toexponential-函数"><a class="markdownIt-Anchor" href="#toexponential-函数">#</a>  <code>toExponential()</code>  函数</h3><p><code>Number</code>  作为一个基本类，可以使用内部类  <code>toExponential()</code>  方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">52.12</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num.toExponential());<span class="comment">// num.toExponential() 函数可以传入参数来控制有效数字位数</span></span><br><span class="line"><span class="comment">// console.log(num.toExponential(-1));// 传入参数非负数，否则会报错</span></span><br><span class="line"><span class="built_in">console</span>.log(num.toExponential(<span class="number">0</span>));</span><br><span class="line"><span class="built_in">console</span>.log(num.toExponential(<span class="number">4</span>));</span><br><span class="line"><span class="built_in">console</span>.log(num.toExponential(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/a45d0102/image-20201031002938496.png" class="" title="image-20201031002938496">]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/blog/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/blog/js/APlayer.min.js&quot; class=&quot;</summary>
      
    
    
    
    <category term="计算机语言学习" scheme="https://shenmingyu.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="JavaScript" scheme="https://shenmingyu.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/JavaScript/"/>
    
    
    <category term="javascript" scheme="https://shenmingyu.gitee.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>CSS实现水平、垂直、水平垂直居中</title>
    <link href="https://shenmingyu.gitee.io/ShenMingyu/a8229322/"/>
    <id>https://shenmingyu.gitee.io/ShenMingyu/a8229322/</id>
    <published>2020-10-30T14:10:43.000Z</published>
    <updated>2020-10-30T15:10:13.503Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/css/APlayer.min.css"><script src="/blog/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/blog/js/Meting.min.js"></script><p>本文仅用于个人学习复习操作，其中样式完全个人完成，希望可以和大家共同进步！</p><p>本文件用于记录样式，方便查找。</p><p>[TOC]</p><h2 id="css实现水平垂直水平垂直居中"><a class="markdownIt-Anchor" href="#css实现水平垂直水平垂直居中">#</a> CSS 实现水平 / 垂直 / 水平垂直居中</h2><blockquote><p>这里不考虑通过具体的元素宽高来进行计算后得到的居中位置，仅为使用固有的 css 属性来进行居中操作</p></blockquote><p>下文中的 HTML 结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">&quot;background-color: #242424;width: 100vw;height: 100vh;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;mediate&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px;height: 100px;background-color: #00FFCC;&quot;</span>&gt;</span>请把我居中<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="水平居中"><a class="markdownIt-Anchor" href="#水平居中">#</a> 水平居中</h3><h4 id="margin"><a class="markdownIt-Anchor" href="#margin">#</a>  <code>margin</code></h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.mediate</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lefttransformtranslatex"><a class="markdownIt-Anchor" href="#lefttransformtranslatex">#</a>  <code>left</code> + <code>transform:translateX</code></h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.mediate</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>);</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="垂直居中"><a class="markdownIt-Anchor" href="#垂直居中">#</a> 垂直居中</h3><h4 id="toptransformtranslatey"><a class="markdownIt-Anchor" href="#toptransformtranslatey">#</a>  <code>top</code> + <code>transform:translateY</code></h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.mediate</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="table-celltext-alignvertical-align"><a class="markdownIt-Anchor" href="#table-celltext-alignvertical-align">#</a>  <code>table-cell</code> + <code>text-align</code> + <code>vertical-align</code></h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: table-cell;</span><br><span class="line"><span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.mediate</span> &#123;</span><br><span class="line"><span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="水平垂直居中"><a class="markdownIt-Anchor" href="#水平垂直居中">#</a> 水平垂直居中</h3><h4 id="flexjustify-contentalign-items"><a class="markdownIt-Anchor" href="#flexjustify-contentalign-items">#</a>  <code>flex</code> + <code>justify-content</code> + <code>align-items</code></h4><p>使用  <code>flex</code>  布局居中块元素以及内文本</p><p><code>flex</code>  中的  <code>justify-content</code>  和  <code>align-items</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.mediate</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="gridjustify-selfalign-self"><a class="markdownIt-Anchor" href="#gridjustify-selfalign-self">#</a>  <code>grid</code> + <code>justify-self</code> + <code>align-self</code></h4><p>使用  <code>grid</code>  布局居中块元素以及内文本</p><p><code>grid</code>  中的  <code>justify-self</code>  和  <code>align-self</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.mediate</span> &#123;</span><br><span class="line">  <span class="attribute">justify-self</span>: center;</span><br><span class="line">  <span class="attribute">align-self</span>: center;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="toplefttransformtranslate"><a class="markdownIt-Anchor" href="#toplefttransformtranslate">#</a>  <code>top</code> + <code>left</code> + <code>transform:translate</code></h4><p>使用  <code>inlilne</code>  布局居中块元素以及内文本</p><p><code>top</code>  和  <code>left</code>  以及  <code>transform: translate()</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.mediate</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/blog/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/blog/js/APlayer.min.js&quot; class=&quot;</summary>
      
    
    
    
    <category term="计算机语言学习" scheme="https://shenmingyu.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="CSS" scheme="https://shenmingyu.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/CSS/"/>
    
    
    <category term="CSS" scheme="https://shenmingyu.gitee.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>论坛项目TP5开发相关问题</title>
    <link href="https://shenmingyu.gitee.io/ShenMingyu/a959b92a/"/>
    <id>https://shenmingyu.gitee.io/ShenMingyu/a959b92a/</id>
    <published>2020-10-27T15:04:15.000Z</published>
    <updated>2020-10-27T16:36:56.166Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/css/APlayer.min.css"><script src="/blog/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/blog/js/Meting.min.js"></script><p>这段时间一直忙着搞项目，期间遇到了不少问题，但是没有及时记录下来，最近略有闲暇，就把之前开发期间遇到的问题详细记录一下。</p><h1 id="页面错误请稍后重试~"><a class="markdownIt-Anchor" href="#页面错误请稍后重试~">#</a> 页面错误！请稍后重试～</h1><!-- 这大概也不算事正式问题，仅仅是模式调整问题 --><p><strong>具体问题如下图：</strong></p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/a959b92a/image-20201027231832643.png" class="" title="image-20201027231832643"><p><strong>问题解析：</strong></p><p>在  <code>config.php</code>  文件中，没有将  <code>‘app_debug’</code>  调整为  <code>true</code> ，由于我当前是开发模式，因此打开开发模式后，TP5 就可以将详细的报错内容以下方其他问题的出现页面格式来呈现。</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/a959b92a/image-20201027232721665.png" class="" title="image-20201027232721665"><h1 id="模块不存在"><a class="markdownIt-Anchor" href="#模块不存在">#</a> 模块不存在：……</h1><p><strong>具体问题如下图：</strong></p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/a959b92a/image-20201027231650460.png" class="" title="image-20201027231650460"><p><strong>问题解析：</strong></p><p>出现这个问题有几种可能，都是方法调用的问题（可以简单理解为路径问题），问题中的 “login” 也可能会是一长串路径，都是类似问题，因此一起解析了。</p><p>我在  <code>application</code>  目录下创建一个文件夹命名为  <code>admin</code> ，在  <code>application/admin</code>  目录下创建一个 PHP class 命名为  <code>Admin.php</code> ，在其中仅仅定义方法  <code>login</code> ，代码如下。</p><p>此时如果我访问  <code>localhost:8080/……/……/admin/admin/login</code> ，会调用这个文件夹下 Admin 文件内的同名函数，此时如果我输入的网址是</p><p><code>localhost:8080/……/……/admin/user/login</code>  或  <code>localhost:8080/……/……/user/admin/login</code>  或  <code>localhost:8080/……/……/admin/admin/signin</code></p><p>之类，就会出现类似这种问题，这里必须要搞清楚的是在  <code>Controller</code>  层、 <code>Model</code>  层以及  <code>View</code>  层的调用关系。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义 Admin 类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> \think\Response</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Admin</span> <span class="keyword">extends</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * login函数，$this-&gt;fetch()会在 view 层中获取 &quot;文件夹名/控制器名/login.html&quot; 并显示</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">login</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;fetch();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 此时如果我将下面函数去除注释并运行，即会出现类似上述问题。</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * public function signin() &#123;</span></span><br><span class="line"><span class="comment">   *   return $this-&gt;fetch();</span></span><br><span class="line"><span class="comment">   * &#125;</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="类的属性不存在路径-属性名"><a class="markdownIt-Anchor" href="#类的属性不存在路径-属性名">#</a> 类的属性不存在：… 路径…-&gt;… 属性名…</h1><p><strong>具体问题如下图：</strong></p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/a959b92a/image-20201027231639127.png" class="" title="image-20201027231639127"><p><strong>问题解析：</strong></p><p>一般来讲连接数据库时会使用类似这样的代码来通过  <code>model</code>  层连接数据库获取信息：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$model = model(<span class="string">&#x27;数据表名&#x27;</span>)-&gt;where(…限制条件…)-&gt;select();</span><br><span class="line"><span class="comment">//当然也有很多其他方法比如 db() 方法，获取时的 find() 、paginate()方法等</span></span><br></pre></td></tr></table></figure><p>所以在  <code>$model</code>  变量中，保存了数据表中符合限制条件的数据，会以对象的方式保存，所以首先就要考虑到在数据表中是否定义了这一个属性，如果定义了仍会报错，那么一定是在调用使用时对属性的名称填写错误，在编写代码时这些小细节一定要注意：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#x2F;* 这里用reactjsx语法来写了(主要是为了markdown中代码格式不变还能注释好看，便于区分哈哈) *&#x2F;&#125;&#125;</span><br><span class="line">&#123;&#123;&#x2F;* 假设 object 中获取了 Admin.php 中 login() 方法链接数据库所得的数据，其中没有 nick_name 这一属性但有 nickname 属性 *&#x2F;&#125;&#125;</span><br><span class="line">&#123;&#123;volist name&#x3D;&quot;values&quot; id&#x3D;&quot;object&quot;&#125;&#125;</span><br><span class="line">&lt;h2&gt;&#123;&#123;$object.nick_name&#125;&#125;&lt;&#x2F;h2&gt;  &#123;&#123;&#x2F;* 这一句会出现上述报错 *&#x2F;&#125;&#125;</span><br><span class="line">&lt;h2&gt;&#123;&#123;$object.nickname&#125;&#125;&lt;&#x2F;h2&gt;  &#123;&#123;&#x2F;* 这一句可以找到数据并正常进行渲染 *&#x2F;&#125;&#125;</span><br></pre></td></tr></table></figure><h1 id="致命错误object-of-classcould-not-be-convert-to-string"><a class="markdownIt-Anchor" href="#致命错误object-of-classcould-not-be-convert-to-string">#</a> 致命错误：Object of class……could not be convert to string</h1><p><strong>具体问题如下图：</strong></p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/a959b92a/image-20201027231626286.png" class="" title="image-20201027231626286"><p><strong>问题解析：</strong></p><p>这种 “致命错误” 的问题，我遇到的大部分都是类型转换的问题，我这里就是典型使用函数错误导致的类的对象无法转换为字符串，这种操作是危险的，以后要避免出现。</p><h1 id="unserialize"><a class="markdownIt-Anchor" href="#unserialize">#</a> unserialize():……</h1><p><strong>具体问题如下图：</strong></p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/a959b92a/image-20201027231620060.png" class="" title="image-20201027231620060"><p><strong>问题解析：</strong></p><p>这个问题是近期遇到的，印象很深，因为没有找到完美的解决方案（没有理解问题的根本），我的解决方法是将 PHP 类中的 index () 函数进行改名，改名之后就不会报出这个错误了，但是目前为止还没有完全理解，网上有很多说是编码格式的问题，但我经过排查发现不是这个原因，其中找到一篇有关 phpstorm 更改命名后出现问题的博文，我发现我的问题可能和这个比较类似，但还是没有解决，不过这篇博文提供了针对这个问题比较全面的解析，这里记录转载一下:</p><p><a href="https://www.cnblogs.com/Renyi-Fan/p/10652715.html">thinkphp 中出现 unserialize (): Error at offset 533 of 1857 bytes 如何解决</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/blog/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/blog/js/APlayer.min.js&quot; class=&quot;</summary>
      
    
    
    
    <category term="项目开发" scheme="https://shenmingyu.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
    <category term="问题记录" scheme="https://shenmingyu.gitee.io/categories/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
    
    <category term="MySQL" scheme="https://shenmingyu.gitee.io/tags/MySQL/"/>
    
    <category term="PHP" scheme="https://shenmingyu.gitee.io/tags/PHP/"/>
    
    <category term="ThinkPHP5" scheme="https://shenmingyu.gitee.io/tags/ThinkPHP5/"/>
    
  </entry>
  
  <entry>
    <title>转载__CSS拓展语言SASS/LESS/Stylus的对比</title>
    <link href="https://shenmingyu.gitee.io/ShenMingyu/603d48bf/"/>
    <id>https://shenmingyu.gitee.io/ShenMingyu/603d48bf/</id>
    <published>2020-10-24T08:53:37.000Z</published>
    <updated>2020-10-24T10:17:37.234Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/css/APlayer.min.css"><script src="/blog/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/blog/js/Meting.min.js"></script><p>在写  <code>CSS</code>  样式表的时候，由于经常需要对具体的颜色等等样式进行更改，而且在一个样式表中常常有很多完全相同的样式，这时候如果单纯使用  <code>CSS</code>  来进行代码编写显然是既耗时又费力的，所以就需要使用一些  <code>CSS</code>  的扩展语言，比方说  <code>Sass</code>  /  <code>Scss</code>  /  <code>Less</code>  /  <code>Stylus</code>  。那么这些扩展语言有哪些具体的语法使用区别呢？</p><p><a href="https://www.sass.hk">Sass/Scss 官网</a></p><p><a href="https://less.bootcss.com">Less 官网</a></p><p><a href="https://stylus.bootcss.com">Stylus 官网</a></p><p>最初想法是自己写一篇总结，后在查询学习过程中，发现有一篇写的非常完善的，那么就在此转载一下就好了，不过由于原文是英文的，阅读有障碍的朋友可以在百度上找到很多这篇文章的翻译版本。</p><h3 id="原文链接sass-vs-less-vs-stylus-preprocessor-shootout"><a class="markdownIt-Anchor" href="#原文链接sass-vs-less-vs-stylus-preprocessor-shootout">#</a> 原文链接：<a href="https://code.tutsplus.com/tutorials/sass-vs-less-vs-stylus-preprocessor-shootout--net-24320">Sass vs. LESS vs. Stylus: Preprocessor Shootout</a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/blog/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/blog/js/APlayer.min.js&quot; class=&quot;</summary>
      
    
    
    
    <category term="计算机语言学习" scheme="https://shenmingyu.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="语法对比" scheme="https://shenmingyu.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E8%AF%AD%E6%B3%95%E5%AF%B9%E6%AF%94/"/>
    
    
    <category term="CSS" scheme="https://shenmingyu.gitee.io/tags/CSS/"/>
    
    <category term="Sass" scheme="https://shenmingyu.gitee.io/tags/Sass/"/>
    
    <category term="Less" scheme="https://shenmingyu.gitee.io/tags/Less/"/>
    
    <category term="Stylus" scheme="https://shenmingyu.gitee.io/tags/Stylus/"/>
    
  </entry>
  
  <entry>
    <title>转载__JavaScript中null、undefined和nan的比较</title>
    <link href="https://shenmingyu.gitee.io/ShenMingyu/2df8937b/"/>
    <id>https://shenmingyu.gitee.io/ShenMingyu/2df8937b/</id>
    <published>2020-10-23T04:43:01.000Z</published>
    <updated>2020-11-11T04:14:12.792Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/css/APlayer.min.css"><script src="/blog/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/blog/js/Meting.min.js"></script><blockquote><p>特别声明：此篇原文内容来源于<a href="https://codeburst.io/@kubamichalski"> @Kuba Michalski</a> 的《<a href="https://codeburst.io/understanding-null-undefined-and-nan-b603cb74b44c">Understanding null, undefined and NaN</a>》一文。著作权归作者所有。</p></blockquote><blockquote><p>博主转载文章链接：<a href="https://www.w3cplus.com/blogs/airen">@Airen</a> 的《<a href="https://www.w3cplus.com/javascript/understanding-null-undefined-and-nan.html">理解 JavaScript 中 null、undefined 和 NaN</a>》一文。</p></blockquote><p>当您开始学习 JavaScript 时，首先需要学习的是数据类型。只要我们讨论 <code>Number</code> 、 <code>String</code> 、 <code>Boolean</code>  和 <code>Object</code>  时，一旦涉及到 <code>null</code>  和 <code>undefined</code>  出现时，作为初学者要理解清楚他们就可能会有点混乱。</p><blockquote><p>如果你和我一样是位 JavaScript 的初学者，建议您花点时间阅读《<a href="https://www.w3cplus.com/javascript/variable-value-data-types.html">变量值的数据类型</a>》一文。</p></blockquote><h2 id="null"><a class="markdownIt-Anchor" href="#null">#</a> null</h2><p><code>null</code>  值表示一个指向不存在或无效的<a href="https://developer.mozilla.org/en-US/docs/Glossary/object">对象</a>或地址（<a href="https://developer.mozilla.org/en-US/docs/Glossary/Null">DMN</a>）引用。即使它指向不存在的东西，也没什么，它是一个全局对象（也是 JavaScript 的原始值之一）。</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/2df8937b/null-nunderfined-nan-1-20201024182006833.png" class="" title="img"><p>否定 <code>null</code>  值返回 <code>true</code> ，但将其与 <code>false</code> （或 <code>true</code> ）进行比较则会给出 <code>false</code> 。</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/2df8937b/null-nunderfined-nan-2-20201024182006866.png" class="" title="img"><p>在基础数学运算中， <code>null</code>  值将被转换为 <code>0</code> 。</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/2df8937b/null-nunderfined-nan-3-20201024182006874.png" class="" title="img"><h2 id="undefined"><a class="markdownIt-Anchor" href="#undefined">#</a> undefined</h2><p>全局属性 <code>nundefined</code>  表示原始值 <code>undefined</code> 。它也是 JavaScript 的原始数据类型（<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined">MDN</a>）。 <code>undefined</code>  是全局作用域的一个变量。 <code>undefined</code>  的最初值就是原始数据类型 <code>undefined</code> 。一个没有被赋值的变量的类型是 <code>undefined</code> 。如果方法或者是语句中操作的变量没有被赋值，则会返回 <code>undefined</code> 。</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/2df8937b/null-nunderfined-nan-4-20201024182006879.png" class="" title="img"><p>当你声明一个变量但没有声明它的值时，JavaScript 会给它赋值 <code>undefined</code> 。</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/2df8937b/null-nunderfined-nan-5-20201024182006870.png" class="" title="img"><p>如果你尝试在任何运算中使用 <code>undefined</code> ，你会得到 <code>NaN</code>  的值。与 <code>null</code>  相似，否定 <code>undefined</code>  值返回 <code>true</code> ，但将其与 <code>true</code>  或 <code>false</code>  作比较则为 <code>false</code> 。</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/2df8937b/null-nunderfined-nan-6-20201024182006885.png" class="" title="img"><h2 id="null-vs-undefined"><a class="markdownIt-Anchor" href="#null-vs-undefined">#</a> null vs undefined</h2><p>那么 <code>null</code>  和 <code>undefined</code>  两者之间有什么区别呢？通过上面的内容，我们来比较一下他们之间的相似点和不同之处。</p><p><strong>相似之处：</strong></p><ul><li>当被否定时，两者的值都是 <code>true</code></li><li>代表了一些不存在的东西…</li></ul><p><strong>差异之处：</strong></p><ul><li><code>null</code>  表示无，完全不存在的； <code>undefined</code>  表示东西没有定义</li><li><code>undefined</code>  有自己的数据类型（ <code>undefined</code> ）， <code>null</code>  只是一个对象</li><li>在基本算术运算中， <code>null</code>  被视为 <code>0</code> ， <code>undefined</code>  返回的 <code>NaN</code></li></ul><p>还有一些事情需要指出来：</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/2df8937b/null-nunderfined-nan-7-20201024182006856.png" class="" title="img"><p><code>undefined == null</code>  返回的值是 <code>true</code> ，因为 JavaScript 会尽力将两个值转换为相同类型。</p><p>第二个语句， <code>undefined === null</code>  和第一个语句有点不同，他们还在比较数据类型（除了比值，还要比两者数据类型）, 加上 JavaScript 很聪明，可以看出他们之间的区别，所以返回的值是 <code>false</code> 。</p><p>第三个和最后一个语句， <code>!undefined == !null</code>  和 <code>!undefined === !null</code>  实际上已经非常的简单。由于两个都是否定的返回值（否定的返回值都是 <code>true</code> ，而且其数据类型也相同），所以最终返回的值是 <code>true</code> 。</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/2df8937b/null-nunderfined-nan-8-20201024182006875.png" class="" title="img"><h2 id="nan-not-a-number"><a class="markdownIt-Anchor" href="#nan-not-a-number">#</a> NaN (Not a Number)</h2><p>通过前文的学习，我们知道了什么是 <code>undefined</code>  和 <code>null</code> ，以及它们之间的差异性，接下来我们来讨论一下 <code>NaN</code>  的值。</p><p>全局 <code>NaN</code>  属性是一个表示非数字的值（<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN">MDN</a>）。</p><p>我认为这个定义很清楚。当我们要得到的数字不是数字时，JavaScript 会返回这个值。例如，当你试图用 <code>cucumber</code>  减去 <code>10</code>  或者用 <code>12</code>  除以 <code>R2D2</code>  时，它们返回的值为 <code>NaN</code> 。</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/2df8937b/null-nunderfined-nan-9-20201024182006877.png" class="" title="img"><p>在某些情况下，你可能期望得到这个值，但事实不如你预期。</p><p>当你在字符串中添加一些东西的时候。如果 JavaScript 看到 <code>+</code>  符号和一个字符串，它会自动将第二个元素添加到字符串中。</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/2df8937b/null-nunderfined-nan-10-20201024182006884.png" class="" title="img"><p>当你用数字和布尔值一起运算的时候，布尔值会转换为 <code>1</code>  和 <code>0</code> 。 <code>true</code>  转为 <code>1</code> ， <code>false</code>  转换为 <code>0</code> 。</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/2df8937b/null-nunderfined-nan-11-20201024182006888.png" class="" title="img"><p>现在，棘手的（或者最棘手的）部分。<strong>NaN 实际上是一个数字</strong>。</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/2df8937b/null-nunderfined-nan-12-20201024182006886.png" class="" title="img"><p>嗯，所以我们可以说它代表了自身的缺失，对吗？更进一步，我们得出结论，它本质上是相反的。</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/2df8937b/null-nunderfined-nan-13-20201024182006888.png" class="" title="img"><p>所以 <code>NaN</code>  和它自身值作比较返回的值是 <code>false</code> 。幸运的是，我们有一个函数可以检查参数是否为 <code>NaN</code> ：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/isNaN"> <code>isNaN()</code> </a>。</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/2df8937b/null-nunderfined-nan-14-20201024182006890.png" class="" title="img"><h2 id="总结"><a class="markdownIt-Anchor" href="#总结">#</a> 总结</h2><p><code>null</code>  表示无、不存在或无效的对象或地址引用。它在简单的数学运算中会转换为 <code>0</code> ，它是一个全局对象。 <code>null == false</code>  返回的值是 <code>false</code> 。</p><p><code>undefined</code>  是一个全局属性，原始值 <code>undefined</code> 。它告诉我们有些东西没有赋值，没有定义。 <code>undefined</code>  不能转换成任何数字，因此在数学计算中使用它，返回的是 <code>NaN</code> 。</p><p><code>NaN</code>  表示一个不是数字的东西，尽管它实际上是一个数字。它不等于它本身，如果要检查是否有东西是 <code>NaN</code>  时，需要借助 <code>isNaN()</code>  函数。</p><p>JavaScript 中喜欢转换值，因此你需要使用三重等号 ( <code>===</code> ) 来确保两个元素是否相同。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/blog/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/blog/js/APlayer.min.js&quot; class=&quot;</summary>
      
    
    
    
    <category term="计算机语言学习" scheme="https://shenmingyu.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="JavaScript" scheme="https://shenmingyu.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/JavaScript/"/>
    
    
    <category term="javascript" scheme="https://shenmingyu.gitee.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>算法学习之迷宫算法</title>
    <link href="https://shenmingyu.gitee.io/ShenMingyu/c6b06df5/"/>
    <id>https://shenmingyu.gitee.io/ShenMingyu/c6b06df5/</id>
    <published>2020-10-10T09:41:58.000Z</published>
    <updated>2020-10-24T10:11:55.064Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/css/APlayer.min.css"><script src="/blog/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/blog/js/Meting.min.js"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/blog/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/blog/js/APlayer.min.js&quot; class=&quot;</summary>
      
    
    
    
    <category term="算法学习" scheme="https://shenmingyu.gitee.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="迷宫算法" scheme="https://shenmingyu.gitee.io/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/%E8%BF%B7%E5%AE%AB%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="C++" scheme="https://shenmingyu.gitee.io/tags/C/"/>
    
    <category term="算法" scheme="https://shenmingyu.gitee.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="迷宫算法" scheme="https://shenmingyu.gitee.io/tags/%E8%BF%B7%E5%AE%AB%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>C++与JavaScript中const对象属性值分析</title>
    <link href="https://shenmingyu.gitee.io/ShenMingyu/ec0db0a4/"/>
    <id>https://shenmingyu.gitee.io/ShenMingyu/ec0db0a4/</id>
    <published>2020-10-04T13:46:02.000Z</published>
    <updated>2020-12-01T10:57:50.705Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/css/APlayer.min.css"><script src="/blog/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/blog/js/Meting.min.js"></script><p>在学习 JavaScript 的过程中，书中提及到了 const 类型变量在对象的使用中出现的具体的细节：</p><blockquote><p>const 实际上保证的并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值）而言，值就保存在变量指向的内存地址中，因此等同于常量。但对于符合类型的数据（主要是对象和数组）而言，变量指向的内存地址保存的只是一个指针，const 只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，这完全不能控制。因此，将一个对象声明为常量时必须非常小心。</p></blockquote><p>使用 JavaScript 声明一个常量对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> objectJS = &#123;&#125;;</span><br><span class="line">objectJS.name = <span class="string">&quot;Javascript&quot;</span>;</span><br><span class="line">objectJS.number = <span class="string">&quot;123456&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再将 objectJS 指向一个空对象</span></span><br><span class="line">objectJS = &#123;&#125;;</span><br></pre></td></tr></table></figure><p>此时发现，出现了报错：</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/ec0db0a4/image-20201004220535667.png" class="" title="image-20201004220535667"><p>而当我们对原对象内部的属性值进行修改时：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 objectJS 内部属性进行更改</span></span><br><span class="line">objectJS.name = <span class="string">&quot;javascript&quot;</span>;</span><br><span class="line">objectJS.number = <span class="number">123456</span>;</span><br></pre></td></tr></table></figure><p>并没有出现报错现象。</p><p>由于之前在课程中学习了 C++，因此对此产生了疑问，现在就来探究一下 C++ 中是否也会出现类似的情况吧！</p><p>使用 C++ 声明一个常量对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectCPP</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">string</span> name = <span class="string">&quot;C++&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> number = <span class="number">654321</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;name:&quot;</span> &lt;&lt; name &lt;&lt; <span class="built_in">endl</span></span><br><span class="line">             &lt;&lt; <span class="string">&quot;number:&quot;</span> &lt;&lt; number &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ObjectCPP objectCpp;</span><br><span class="line">    objectCpp.<span class="built_in">display</span>();</span><br><span class="line">    objectCpp.name = <span class="string">&quot;CPlusPlus&quot;</span>;</span><br><span class="line">    objectCpp.number = <span class="number">123456</span>;</span><br><span class="line">    objectCpp.<span class="built_in">display</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现已经出现了报错：</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/ec0db0a4/image-20201004222712611.png" class="" title="image-20201004222712611"><p>具体问题描述为：</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/ec0db0a4/image-20201004222757997.png" class="" title="image-20201004222757997"><p>经过学习，了解到在 C++ 中，常量对象是完全不可以被修改的一个对象，包括其内部的各个属性值，对于常量对象，有两种形式：类型 const 对象名  或  const 类型 对象名，而且必须手动创建类内的构造函数来赋予该常量对象初值，否则其成员变量将永远是 “垃圾值”。</p><p>这也体现出了 JavaScript 和 C++ 之间的不同之处。</p><hr><p>参考资料：</p><p><a href="https://blog.csdn.net/u010191243/article/details/39269753?utm_source=blogxgwz5">C++ 常量及常对象、成员汇总</a></p><p><a href="https://segmentfault.com/a/1190000004085259">C++ 常量对象、常量成员函数</a></p><p><a href="https://blog.csdn.net/Patrick_Lyle/article/details/76032978?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">C++ 常量对象，成员函数，引用</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/blog/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/blog/js/APlayer.min.js&quot; class=&quot;</summary>
      
    
    
    
    <category term="计算机语言学习" scheme="https://shenmingyu.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
    
    <category term="语法对比" scheme="https://shenmingyu.gitee.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/%E8%AF%AD%E6%B3%95%E5%AF%B9%E6%AF%94/"/>
    
    
    <category term="C++" scheme="https://shenmingyu.gitee.io/tags/C/"/>
    
    <category term="JavaScript" scheme="https://shenmingyu.gitee.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>《ES6标准入门》阅读所遇问题分析</title>
    <link href="https://shenmingyu.gitee.io/ShenMingyu/710b8415/"/>
    <id>https://shenmingyu.gitee.io/ShenMingyu/710b8415/</id>
    <published>2020-10-04T12:56:55.000Z</published>
    <updated>2020-10-08T07:18:30.773Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/css/APlayer.min.css"><script src="/blog/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/blog/js/Meting.min.js"></script><p>笔者于  <code>2020/10/1</code>  开始阅读本书，本文记录读书过程中所遇疑问与困惑，并尽量对这些问题进行初步解答，由于初学，所提问题可能比较奇怪甚至莫名其妙，还请多多谅解，回答谨为个人对问题的看法与观点，如有不正确指出，还请不吝赐教。</p><h2 id="在使用-iife-中使用-varlet-的作用是否能与块级作用域中的-letvar-作用相同"><a class="markdownIt-Anchor" href="#在使用-iife-中使用-varlet-的作用是否能与块级作用域中的-letvar-作用相同">#</a> 在使用 IIFE 中使用 var/let 的作用是否能与块级作用域中的 let/var 作用相同？</h2><p>问题为思考书 P24 后提出，由于对 javascript 的理解不深，故提出该问题，并实操进行对比。</p><p>书本中提出：</p><blockquote><p>块级作用域的出现，实际上使得获得广泛应用的立即执行匿名函数（IIFE）不再必要了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IIFE 写法</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> tmp = ...;</span><br><span class="line">...</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 块级作用域写法</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">let</span> temp = ...;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>根据前面所学，由于块级作用域的特性：外层作用域无法读取内层作用域的变量，而目前所理解的 IIFE 的作用为将其中的部分变量函数等与外部分隔开来，那么在块级作用域中使用 var 和 let 类型变量的效果与在 IIFE 中使用 let 和 var 类型变量是否有区别呢？</p><p>编写代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IIFE 写法内 var 与 let 的显示情况</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> IIFELet = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> IIFEVar = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(IIFELet);</span><br><span class="line">  <span class="built_in">console</span>.log(IIFEVar);</span><br><span class="line">&#125;())</span><br><span class="line"><span class="comment">// console.log(IIFELet);</span></span><br><span class="line"><span class="comment">// console.log(IIFEVar);</span></span><br></pre></td></tr></table></figure><p>上述代码运行后，函数内部的输出语句都正常输出，函数外部两语句分别运行也都出现报错：</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/710b8415/image-20201004212336517.png" class="" title="image-20201004212336517"><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/710b8415/image-20201004212407655.png" class="" title="image-20201004212407655"><p>这说明立即执行匿名函数的变量作用域是被局限在了函数体作用域的内部，函数执行完毕后，变量会被释放，导致了外部无法识别内部变量。</p><p>而当使用块级作用域时，出现了不同的情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 块级作用域写法内 var 与 let 的显示情况</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> blockLet = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> blockVar = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(blockLet);</span><br><span class="line">  <span class="built_in">console</span>.log(blockVar);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// console.log(blockLet);</span></span><br><span class="line"><span class="comment">// console.log(blockVar);</span></span><br></pre></td></tr></table></figure><p>在块级作用域内部的两个输出语句也正常输出，在外部使用 let 时也出现了报错现象，这也匹配了了 let 关键词的适用范围，当函数结束后会导致变量释放而导致无法识别。</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/710b8415/image-20201004213050591.png" class="" title="image-20201004213050591"><p>但当输出 var 类型变量时，块级作用域依旧能够正常输出变量的值。</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/710b8415/image-20201004213350362.png" class="" title="image-20201004213350362"><p>根据书中所描述的：</p><blockquote><p>ES5 只有全局作用域和函数作用域，没有块级作用域，这导致很多场景不合理</p><ul><li>内层变量可能会覆盖外层变量</li><li>用来计数的循环变量泄露为全局变量</li></ul></blockquote><p>进行推断，个人认为块级作用域的作用即将内外层相互隔离，从而实现防止全局污染的情况，但 var 类型变量却能够成功打印，这貌似与块级作用域设计出现的初衷有所不同，也就是说块级作用域也有限制，即需要使用 let 类型变量才可以实现块级作用域的内外层隔离，所以目前个人认为在某种程度上，IIFE 的使用可能比块级作用域更加安全。</p><h3 id="对比const-类型的对象在-javascript-中是无法控制对象内部的属性值的变化的那么-c-中是否也是如此"><a class="markdownIt-Anchor" href="#对比const-类型的对象在-javascript-中是无法控制对象内部的属性值的变化的那么-c-中是否也是如此">#</a> <a href="/blog/ShenMingyu/ec0db0a4/">对比：const 类型的对象在 JavaScript 中是无法控制对象内部的属性值的变化的，那么 C++ 中是否也是如此？</a></h3><h1 id="在-javascript-中-function-是什么意思"><a class="markdownIt-Anchor" href="#在-javascript-中-function-是什么意思">#</a> 在 JavaScript 中 “!function (){}()” 是什么意思？</h1><p>参考链接：</p><p><a href="https://zhidao.baidu.com/question/1830337028432640660.html">在 JavaScript 中 “!function (){}()” 是什么意思？</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;())</span><br></pre></td></tr></table></figure><p>以上是两种 JavaScript 立即执行函数的常见写法，要理解立即执行函数，需要先理解一些函数的基本概念。</p><p><strong>函数声明：</strong></p><p><code>function fnName () &#123;…&#125;;</code>  使用  <code>function</code>  关键字声明一个函数，再指定一个函数名，叫函数声明。</p><p><strong>函数表达式：</strong></p><p><code>var fnName = function () &#123;…&#125;;</code>  使用  <code>function</code>  关键字声明一个函数，但未给函数命名，最后将匿名函数赋予一个变量，叫函数表达式，这是最常见的函数表达式语法形式。</p><p><strong>匿名函数：</strong></p><p><code>function () &#123;&#125;;</code>   使用  <code>function</code>  关键字声明一个函数，但未给函数命名，所以叫匿名函数，匿名函数属于函数表达式，匿名函数有很多作用，赋予一个变量则创建函数，赋予一个事件则成为事件处理程序或创建闭包等等。</p><p><strong>函数声明和函数表达式不同之处在于：</strong></p><ol><li><p>JavaScript 引擎在解析 JavaScript 代码时会 ‘函数声明提升’（Function declaration Hoisting）当前执行环境（作用域）上的函数声明。</p><!-- 函数提升这一点在 ES6 中依旧予以保留，包括在块级作用域内的情况 --><p>而函数表达式必须等到 JavaScript 引擎执行到它所在行时，才会从上而下一行一行地解析函数表达式。</p></li><li><p>函数表达式后面可以加括号立即调用该函数，函数声明不可以，只能以 fnName () 形式调用。</p><p>在 function 前面加！、+、 - 甚至是逗号等到都可以起到函数定义后立即执行的效果，而（）、！、+、-、= 等运算符，都将函数声明转换成函数表达式。</p><p>消除了 JavaScript 引擎识别函数表达式和函数声明的歧义，告诉 JavaScript 引擎这是一个函数表达式，不是函数声明，可以在后面加括号，并立即执行函数的代码。</p></li></ol><p>扩展资料</p><p>作用：</p><p>JavaScript 中没用私有作用域的概念，如果在多人开发的项目上，你在全局或局部作用域中声明了一些变量，可能会被其他人不小心用同名的变量给覆盖掉。</p><p>根据 JavaScript 函数作用域链的特性，可以使用这种技术可以模仿一个私有作用域，用匿名函数作为一个 “容器”。</p><p>“容器” 内部可以访问外部的变量，而外部环境不能访问 “容器” 内部的变量，所以 ( function (){…} )() 内部定义的变量不会和外部的变量发生冲突，俗称 “匿名包裹器” 或 “命名空间”。</p><p>JQuery 使用的就是这种方法，将 JQuery 代码包裹在 (function (window,undefined){…jquery 代码…} (window) 中，在全局作用域中调用 JQuery 代码时，可以达到保护 JQuery 内部变量的作用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/blog/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/blog/js/APlayer.min.js&quot; class=&quot;</summary>
      
    
    
    
    <category term="读书笔记" scheme="https://shenmingyu.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="技术书籍" scheme="https://shenmingyu.gitee.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8A%80%E6%9C%AF%E4%B9%A6%E7%B1%8D/"/>
    
    
    <category term="读书笔记" scheme="https://shenmingyu.gitee.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>云翼计划建站流程</title>
    <link href="https://shenmingyu.gitee.io/ShenMingyu/5f8623e6/"/>
    <id>https://shenmingyu.gitee.io/ShenMingyu/5f8623e6/</id>
    <published>2020-09-29T15:58:08.000Z</published>
    <updated>2020-09-29T18:02:43.472Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/css/APlayer.min.css"><script src="/blog/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/blog/js/Meting.min.js"></script><p>在今年 2 月 3 月份的时候，我通过云翼计划的学生试用，经过考试之后，免费得到了第一台云服务器（半年期，47.113.87.183 很好听的公网 ip 地址嘻嘻，可惜不能以云翼计划学生优惠的价格进行续费，已经过期了），由于当时经验不足，踩了很多坑，浪费了很多时间好不容易搭建好了环境，写好了个人网站主页，部署到服务器上，再加上各种做其他项目上的小问题，兜兜转转地时间也快到期了，于是便在阿里云云翼计划中购买了第一台云服务器，上一次没有描述整体建站流程的想法，这次就把它补起来！</p><h2 id="建站流程"><a class="markdownIt-Anchor" href="#建站流程">#</a> 建站流程</h2><h3 id="购买云服务器"><a class="markdownIt-Anchor" href="#购买云服务器">#</a> 购买云服务器</h3><p>首先，进入<a href="https://promotion.aliyun.com/ntms/act/campus2018.html?spm=5176.12818093.0.0.845916d08qhqZi">阿里云云翼计划首页</a>，向下滑动，找到学生优惠套餐</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/5f8623e6/image-20200930000723780.png" class="" title="image-20200930000723780"><p>我购买的是第一个 “云服务器 ECS 学生专享”，然后选择地域、操作系统和购买时长，下方应当会显示价格为 114 元。</p><!-- 要先进行学生认证哦 --><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/5f8623e6/image-20200930000832984.png" class="" title="image-20200930000832984"><p>然后根据流程进行购买，成功交易后很快服务器就开通好了。然后就可以进入云服务器进行具体的环境配置啦。</p><h3 id="云服务器环境配置"><a class="markdownIt-Anchor" href="#云服务器环境配置">#</a> 云服务器环境配置</h3><p>可以参考我之前的博客文章 <a href="/blog/ShenMingyu/">Ubuntu 云服务器下载安装 LAMP</a> 和 <a href="/blog/ShenMingyu/">Ubuntu 云服务器下载安装 LNMP</a> 哦！这里就不再赘述了。</p><h3 id="域名购买及备案"><a class="markdownIt-Anchor" href="#域名购买及备案">#</a> 域名购买及备案</h3><p>我是在 <a href="https://mi.aliyun.com">万网</a> 上购买了两个域名（ myspegale.tech 是之前买的，最近新增并使用 <a href="http://shenmingyu.com">shenmingyu.com</a> 作为主要域名），购买完成后即可在阿里云的域名备案中心进行域名的备案。一般来讲这个过程会有两周左右的时间。</p><ul><li>备案的条件：<ul><li>购买了域名</li><li>购买了服务器</li><li>主办单位证件（个人就是身份证）</li></ul></li></ul><p>需要进行实名认证，网站名称在备案时是有要求的，部分要求如下：</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/5f8623e6/image-20200930005052031.png" class="" title="image-20200930005052031"><p>更加详细的要求可以去询问客服哦。客服小哥哥小姐姐们还是很耐心的，我之前第一次备案的时候就是因为网站名称的问题，接到了阿里云的电话，经过一番修改定夺之后才最后成功备案的。</p><p>…………… 假装经过了漫长的备案时间 ……………</p><p>备案完成后，需要根据备案的需求，在你的网站底部添加备案的 ICP 号，并且要在 30 天内去进行公安备案，这个详细的可以查阅阿里云的相关文档，里面有很详细的流程阐述。</p><!-- 在备案过程中，你所购买的域名是可以进行 DNS 解析的，但是暂时无法进行国内的 CDN 加速服务。 --><h3 id="域名的-dns-解析"><a class="markdownIt-Anchor" href="#域名的-dns-解析">#</a> 域名的 DNS 解析</h3><h3 id="网站的-cdn-加速"><a class="markdownIt-Anchor" href="#网站的-cdn-加速">#</a> 网站的 CDN 加速</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/blog/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/blog/js/APlayer.min.js&quot; class=&quot;</summary>
      
    
    
    
    <category term="网站搭建" scheme="https://shenmingyu.gitee.io/categories/%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"/>
    
    
    <category term="环境搭建" scheme="https://shenmingyu.gitee.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    <category term="Apache" scheme="https://shenmingyu.gitee.io/tags/Apache/"/>
    
    <category term="Nginx" scheme="https://shenmingyu.gitee.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>React资源引用问题及解决方案</title>
    <link href="https://shenmingyu.gitee.io/ShenMingyu/a0d6d312/"/>
    <id>https://shenmingyu.gitee.io/ShenMingyu/a0d6d312/</id>
    <published>2020-09-27T12:53:47.000Z</published>
    <updated>2020-09-28T10:48:54.536Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/css/APlayer.min.css"><script src="/blog/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/blog/js/Meting.min.js"></script><p>问题截图描述：</p><p>在本地安装下载 react 环境后，引用资源，但是在代码编写后 faxing 无法渲染，出现了如下错误：</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/a0d6d312/image-20200927205703698.png" class="" title="image-20200927205703698"><p>提示为 ReactDom 函数不是一个函数，这就很奇怪。</p><p>使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm info react</span><br><span class="line"></span><br><span class="line">npm info react-dom</span><br><span class="line"></span><br><span class="line">npm info babel-standalone</span><br></pre></td></tr></table></figure><p>查询发现都是最新版本，没有问题。</p><p>进入 babel 官网查询问题，根据 <a href="https://babeljs.io/docs/setup/">这个网址</a> 内容进行创建 babel.config.json 文件并在其中添加下述代码，</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;@babel/preset-env&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依然没有解决，在浏览器中依然报错并且无法渲染。</p><p>根据网上许多博客内容，更改  <code>ReactDom</code>  为  <code>ReactDOM</code>  依旧没有效果，仍然显示没有该函数。</p><h3 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法">#</a> 解决方法：</h3><p>在 <a href="https://www.runoob.com/react/react-install.html">菜鸟教程 react 教程</a> 中直接引用老版本的  <code>react.development.js</code> ， <code>react-dom.development.js</code>  和  <code>babel.min.js </code>  三个文件，即直接使用其中推荐的 CDN 来使用。发现成功了。</p><p>目前分析看来应该是本地安装的资源和网上使用的资源有一定的不同导致的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Staticfile CDN 的 React CDN 库 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.staticfile.org/react/16.4.0/umd/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.staticfile.org/react-dom/16.4.0/umd/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 生产环境中不建议使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.staticfile.org/babel-standalone/6.26.0/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 官方提供的cdn地址 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react@16/umd/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 生产环境中不建议使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/babel-standalone@6.15.0/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/a0d6d312/image-20200927210612863.png" class="" title="image-20200927210612863"><h3 id="问题分析"><a class="markdownIt-Anchor" href="#问题分析">#</a> 问题分析：</h3><p>到目前为止（2002/9/27）还没有发现具体问题，对比 cdn 上的文件和安装的本地文件发现其中的区别非常大，在百度中暂时无法找出问题所在，目前个人认为可能是新版本对函数的名称以及使用方法进行了更新，导致无法识别代码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/blog/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/blog/js/APlayer.min.js&quot; class=&quot;</summary>
      
    
    
    
    <category term="Web前端" scheme="https://shenmingyu.gitee.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    <category term="框架" scheme="https://shenmingyu.gitee.io/categories/Web%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="React" scheme="https://shenmingyu.gitee.io/categories/Web%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/React/"/>
    
    
    <category term="React" scheme="https://shenmingyu.gitee.io/tags/React/"/>
    
    <category term="环境搭建" scheme="https://shenmingyu.gitee.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    <category term="解决方案" scheme="https://shenmingyu.gitee.io/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>React基础</title>
    <link href="https://shenmingyu.gitee.io/ShenMingyu/e0d98019/"/>
    <id>https://shenmingyu.gitee.io/ShenMingyu/e0d98019/</id>
    <published>2020-09-27T09:05:08.000Z</published>
    <updated>2020-09-29T05:42:57.160Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/css/APlayer.min.css"><script src="/blog/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/blog/js/Meting.min.js"></script><p>前面已经搭建好使用 React 的环境了，现在可以在 React 目录下创建 html 文件开始学习了。</p><p>创建  <code>helloReact.html</code>  文件，一定要引入以下三个文件</p><p>react.development.js</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./node_modules/react/umd/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>react-dom.development.js</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./node_modules/react-dom/umd/react-dom.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>babel.min.js</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./node_modules/babel-standalone/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在文件内创建一个根结点， <code>id=&quot;rootReact&quot;</code> ，作为 React 的根结点</p><ul><li><p><strong>根结点：</strong></p><blockquote><p>一个页面当中需要又一个根结点，这个根结点下面的内容会被 react 管理</p></blockquote></li></ul><p>在该  <code>div</code>  块下方使用  <code>script</code>  块， <code>type=&quot;babel&quot;</code></p><p>在这个  <code>script</code>  块中，语法一定要使用 <mark>jsx</mark> 的语法。</p><p>jsx 详见<a href="/blog/ShenMingyu/90576cc9/"> React JSX 基础</a></p><p>引用上面的本地文件时，出现了无法渲染的问题，具体问题描述见 <a href="/blog/ShenMingyu/a0d6d312/">React 资源引用问题及解决方案</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/blog/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/blog/js/APlayer.min.js&quot; class=&quot;</summary>
      
    
    
    
    <category term="Web前端" scheme="https://shenmingyu.gitee.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    <category term="框架" scheme="https://shenmingyu.gitee.io/categories/Web%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="React" scheme="https://shenmingyu.gitee.io/categories/Web%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/React/"/>
    
    
    <category term="React" scheme="https://shenmingyu.gitee.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React环境搭建问题及解决方案</title>
    <link href="https://shenmingyu.gitee.io/ShenMingyu/fa16b3db/"/>
    <id>https://shenmingyu.gitee.io/ShenMingyu/fa16b3db/</id>
    <published>2020-09-27T08:08:00.000Z</published>
    <updated>2020-09-29T05:41:13.351Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/css/APlayer.min.css"><script src="/blog/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/blog/js/Meting.min.js"></script><p><strong>问题截图描述：</strong></p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/fa16b3db/image-20200927161628616.png" class="" title="image-20200927161628616"><h3 id="npm-warn-react100-no-description"><a class="markdownIt-Anchor" href="#npm-warn-react100-no-description">#</a> npm WARN React@1.0.0 No description</h3><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/fa16b3db/image-20200927161105736.png" class="" title="image-20200927161105736"><p>该问题是在执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install react --save</span><br></pre></td></tr></table></figure><p>时遇到的问题。</p><h3 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法">#</a> 解决方法：</h3><p>使用 vim 或编辑器打开  <code>package.json</code>  文件，初始界面如下：</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/fa16b3db/image-20200927161258089.png" class="" title="image-20200927161258089"><p>在  <code>&quot;description&quot;</code>  中任意添加描述（随便填，非空即可）</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/fa16b3db/image-20200927161554677.png" class="" title="image-20200927161554677"><p>此时发现警告少了一个。</p><h3 id="npm-warn-react100-no-repository-field"><a class="markdownIt-Anchor" href="#npm-warn-react100-no-repository-field">#</a> npm WARN React@1.0.0 No repository field.</h3><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/fa16b3db/image-20200927161716557.png" class="" title="image-20200927161716557"><h3 id="解决方法-2"><a class="markdownIt-Anchor" href="#解决方法-2">#</a> 解决方法：</h3><p>问题依然在  <code>package.json</code>  文件中，添加  <code>&quot;private”</code>  字段，并设置为  <code>true</code> 。</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/fa16b3db/image-20200927161941033.png" class="" title="image-20200927161941033"><p>再次执行，发现警告已经消除，问题解决。</p><img src= "/blog/img/loading.gif" data-lazy-src="/blog/ShenMingyu/fa16b3db/image-20200927162005921.png" class="" title="image-20200927162005921"><h2 id="问题分析"><a class="markdownIt-Anchor" href="#问题分析">#</a> 问题分析：</h2><p>npm 默认自动生成的  <code>package.json</code>  没有自动设置的默认描述和存储库权限，这里需要手动进行设置。</p><p>返回 <a href="/blog/ShenMingyu/28a0bfec/">React 环境搭建</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/blog/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/blog/js/APlayer.min.js&quot; class=&quot;</summary>
      
    
    
    
    <category term="Web前端" scheme="https://shenmingyu.gitee.io/categories/Web%E5%89%8D%E7%AB%AF/"/>
    
    <category term="框架" scheme="https://shenmingyu.gitee.io/categories/Web%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/"/>
    
    <category term="React" scheme="https://shenmingyu.gitee.io/categories/Web%E5%89%8D%E7%AB%AF/%E6%A1%86%E6%9E%B6/React/"/>
    
    
    <category term="React" scheme="https://shenmingyu.gitee.io/tags/React/"/>
    
    <category term="环境搭建" scheme="https://shenmingyu.gitee.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
    <category term="npm" scheme="https://shenmingyu.gitee.io/tags/npm/"/>
    
    <category term="解决方案" scheme="https://shenmingyu.gitee.io/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
</feed>
